# 1.数据类型

本章讨论讨论的数据类型均为各语言的基本数据类型的定义形式和类型相关，即语言内建类型或储存于语言栈上的数据类型（不包括OOP相关)  

囊括的语言包括  

|	语言	|	版本		|
|	----	|	----		|
|	c++		|	c++11		|
| 	java		|	11			|
|	Python	|	3.7.5		|
|	Go		|	1.14			|
|	Rust	|	1.43			|
|	Scala	|	2.13.1		|
|	Clojure	|	1.10.0		|
|	Kotlin	|	1.3.60		|


## C++
> constant define
	
>>	1. macro
>>> \#<font size=5 color=#0000ff>define</font> <font color=#000000>MAX\_NUM_SIZE</font> 512
	 
>>	2. constant
>>> <font size=5 color=#0000ff>const</font> int <font color=#000000>MAX\_NUM_SIZE</font> = 512;  

----
>> 
	1. define 定义常量的问题
		1.1. #define不涉及为定义的常量做类型检查，为了显式地指定常量类型，需要在常量后加上后缀。比如，对于float类型的常量，在数字后面加上f后缀。  
		1.2. #define定义的常量是全局的。  
		1.3. 不能把#define定义的常量标记为公有的，受保护的，或者私有的，它本质上是公有的。  
		1.4.  宏可能会被预处理器从代码中剥离，这样，编译器就无法看见这个名字。这样，程序员在调试时只能看到一些没有任何描述性的常量值。	
	2.  const 定义常量的问题
		2.1. 在默认情况下，以这种方式定义的变量会促使编译器为每个包含此头文件的模块分配变量存储空间。如果定义了很多常量，并且该头文件被很多.cpp文件包含，那么会导致.o目标文件和最终的二进制文件膨胀  
		2.2.  使用extern来声明的常量是全局的，若要将常量的作用域限制在类中，则须在类中声明常量，并将其声明为static（这样它们就不会计入每个对象的内存大小中  .
		2.3. 在某些情况下，使用枚举类型代替常量也可以避免文件空间膨胀的问题。 
		
	
> variable define

> type system



  


## Java


## Python


##  Go


## Rust

## Scala

## Clojure

## Kotlin

	

		
